[{"title":"Go:type关键词总结","url":"https://wdft.com/2020/02/27/type/","content":"<!-- toc -->\n\n<h1 id=\"type关键词总结\"><a href=\"#type关键词总结\" class=\"headerlink\" title=\"type关键词总结\"></a>type关键词总结</h1><h3 id=\"type-用法：\"><a href=\"#type-用法：\" class=\"headerlink\" title=\"type 用法：\"></a>type 用法：</h3><ul>\n<li>定义结构体</li>\n<li>定义接口 </li>\n<li>类型别名 </li>\n<li>类型定义</li>\n<li>类型开关</li>\n</ul>\n<p>类型定义和类型别名的区别：<br>区别就是类型定义是完全定义了一种新的类型，<br>而类型别名只是给现有的类型取了一个别名alias。（编译器会替换成基本类型。）</p>\n<h3 id=\"Type常见Demo\"><a href=\"#Type常见Demo\" class=\"headerlink\" title=\"Type常见Demo\"></a>Type常见Demo</h3><h6 id=\"定义结构体\"><a href=\"#定义结构体\" class=\"headerlink\" title=\"定义结构体\"></a>定义结构体</h6><pre><code>type Demo struct {}\n</code></pre><h6 id=\"定义接口\"><a href=\"#定义接口\" class=\"headerlink\" title=\"定义接口\"></a>定义接口</h6><pre><code>type Demoer interface {}\n</code></pre><h6 id=\"类型别名\"><a href=\"#类型别名\" class=\"headerlink\" title=\"类型别名\"></a>类型别名</h6><pre><code>type Demo string\n</code></pre><h6 id=\"类型定义\"><a href=\"#类型定义\" class=\"headerlink\" title=\"类型定义\"></a>类型定义</h6><pre><code>type handle func(str string) \n</code></pre><h6 id=\"类型开关\"><a href=\"#类型开关\" class=\"headerlink\" title=\"类型开关\"></a>类型开关</h6><pre><code>func Demo(params ...interface{})  {\n   for i, x := range params {\n      switch x.(type) {\n      case bool:\n         fmt.Printf(&quot;type #%d is bool&quot;,i)\n      default:\n         fmt.Printf(&quot;type is unknow&quot;)\n      }\n   }\n}\n</code></pre><h3 id=\"类型注意事项\"><a href=\"#类型注意事项\" class=\"headerlink\" title=\"类型注意事项\"></a>类型注意事项</h3><h6 id=\"类型比较\"><a href=\"#类型比较\" class=\"headerlink\" title=\"类型比较\"></a>类型比较</h6><p>备注：<br>参考Go文档type说明： </p>\n<ul>\n<li><p>命名类型（简单类型），有类型名称如 int, int64, float, string, bool. 还有自定义的命名类型。 </p>\n</li>\n<li><p>非命名类型（复杂类型），没类型名称 array slice, map，func(){}, interface{}。但是<strong>chan类型是可以==比较</strong>。</p>\n<ul>\n<li>slice 内存不连续，底层对象分开放的，不能直接比较； </li>\n<li>map 内存不连续，底层对象独立存放，不能直接比较；</li>\n<li>chan 内存是连续的，单一对象，可以直接比较；</li>\n</ul>\n</li>\n<li><p>当比较两个命名类型的时候，类型名称必须一样；当比较命名类型和非命名类型的时候，<strong>底层类型一样即可</strong>。</p>\n</li>\n<li><p>比较基于两个原则：1.内存底层基本类型；2.类型本身是否确定类型或不稳定类型；</p>\n</li>\n<li><p>空接口值比较</p>\n</li>\n</ul>\n<pre><code>package main\n\nimport (\n    &quot;fmt&quot;\n    &quot;reflect&quot;\n)\n\ntype T1 []string\ntype T2 []string\n\nfunc main() {\n    foo0 := []string{}\n    foo1 := T1{}\n    foo2 := T2{}\n    fmt.Println(reflect.TypeOf(foo0))\n    fmt.Println(reflect.TypeOf(foo1))\n    fmt.Println(reflect.TypeOf(foo2))\n\n    // Output:\n    // []string\n    // main.T1\n    // main.T2\n\n    //编译通，反之亦然\n    //foo1 = foo0\n    //foo0 = foo1\n\n    // 编译不通过\n    // 错误提示：cannot use foo2 (type T2) as type T1 in assignment\n    foo2 = foo0\n   foo1 = foo2 //cannot\n\n\n\n   //编译通过：chan\n   ch1 := make(chan int)\n   ch2 := make(chan int)\n   fmt.Println(ch1 == ch2)   \n\n   //编译不通过：slice\n   s1 := []int{1,2}\n   s2 := []int{2,1}\n   fmt.Println(s1 == s2)\n\n   //编译不通过：map\n   m1 := make(map[int]int)\n   m2 := make(map[int]int)\n   fmt.Println(m1 == m2)\n}\n</code></pre><h6 id=\"类型可比较性\"><a href=\"#类型可比较性\" class=\"headerlink\" title=\"类型可比较性\"></a>类型可比较性</h6><p>判断原则：<br>底层数据结构类型是否稳定和一致</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">类型</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">map</td>\n<td align=\"left\">宕机错误，不可比较</td>\n</tr>\n<tr>\n<td align=\"left\">切片（[]T）</td>\n<td align=\"left\">宕机错误，不可比较</td>\n</tr>\n<tr>\n<td align=\"left\">通道（channel）</td>\n<td align=\"left\">可比较，必须由同一个 make 生成，也就是同一个通道才会是 true，否则为 false</td>\n</tr>\n<tr>\n<td align=\"left\">数组（[容量]T）</td>\n<td align=\"left\">可比较，编译期知道两个数组是否一致</td>\n</tr>\n<tr>\n<td align=\"left\">结构体</td>\n<td align=\"left\">可比较，可以逐个比较结构体的值</td>\n</tr>\n<tr>\n<td align=\"left\">函数</td>\n<td align=\"left\">可比较</td>\n</tr>\n</tbody></table>\n","categories":["Go"],"tags":["Go,type关键词总结"]},{"title":"Go:package time","url":"https://wdft.com/2020/02/27/time/","content":"<!-- toc -->\n\n<h1 id=\"package-time\"><a href=\"#package-time\" class=\"headerlink\" title=\"package time\"></a>package time</h1><h3 id=\"time-转换注意事项\"><a href=\"#time-转换注意事项\" class=\"headerlink\" title=\"time 转换注意事项\"></a>time 转换注意事项</h3><p>Go语言指定时间原点</p>\n<pre><code>package main\n\nimport (\n    &quot;time&quot;\n    &quot;fmt&quot;\n)\n\nfunc main()  {\n    //当前时间格式化，记忆规律：创始年份2016 | 一 | 二 | 三（15时，即 3 pm） | 四 | 五\n    nowTime := time.Now().Format(&quot;2006-01-02 15:04:05&quot;)\n    fmt.Println(nowTime)\n}</code></pre>","categories":["Go"],"tags":["Go,package time"]},{"title":"Go:switch","url":"https://wdft.com/2020/02/27/switch/","content":"<!-- toc -->\n\n<h1 id=\"switch\"><a href=\"#switch\" class=\"headerlink\" title=\"switch\"></a>switch</h1><h3 id=\"switch-注意事项\"><a href=\"#switch-注意事项\" class=\"headerlink\" title=\"switch 注意事项\"></a>switch 注意事项</h3><ul>\n<li>fallthrough不能用在switch的最后一个分支。</li>\n</ul>\n","categories":["Go"],"tags":["Go,switch"]},{"title":"Go:struct","url":"https://wdft.com/2020/02/27/struct/","content":"<!-- toc -->\n\n<h1 id=\"struct\"><a href=\"#struct\" class=\"headerlink\" title=\"struct\"></a>struct</h1><h3 id=\"面向对象Class类的底层实现从某些方面说就是结构体，对象的引用就是指针，只是语言把他们封装起来了而已。\"><a href=\"#面向对象Class类的底层实现从某些方面说就是结构体，对象的引用就是指针，只是语言把他们封装起来了而已。\" class=\"headerlink\" title=\"面向对象Class类的底层实现从某些方面说就是结构体，对象的引用就是指针，只是语言把他们封装起来了而已。\"></a>面向对象Class类的底层实现从某些方面说就是结构体，对象的引用就是指针，只是语言把他们封装起来了而已。</h3><p>Golang的Struct结构体（源于C语言，但又有别于C）的灵活性：<br>go语言中并没有像C++，Java语言中这类的Class，它只含有像C语言中的结构体，用结构体和指针等特性，完成一个类的作用，很巧妙的使用了指针和结构体，不仅是go的面向对象，包括go语言中的map等操作都是借助了结构体。其实，说白了，C++、Java等面向对象的语言中，类的底层实现就是结构体，对象的引用就是指针，只是语言把他们封装起来了而已。很多人刚接触面向对象很不理解这些东西也应该缘于此。<br>或者说，面向对象的封装在某种意义上是以牺牲灵活特性的为代价的一种抽象简化。</p>\n<p>所有高级语言(PHP、Java、Python、JavaScript等等…)的数组Array、字典map、Slice切片、Json等结构类型往往只是叫法不一样，多少都源于C系或者受到C系的Struct结构体思想的影响,在某些特定领域内，做了一些针对性的解决方案。</p>\n<p>PHP就是c语言实现的一套高级“程序”语言，只不过是这套“程序化的语言”的规范和语法等机制可以用来快速做web领域的事情，通过解释器，转成底层语言完成代码的最终执行。</p>\n<p>这也印证了很多答案往往追根溯源都在计算机数据结构基础里没有捷径可以走。</p>\n<h3 id=\"golang-struct注意事项：\"><a href=\"#golang-struct注意事项：\" class=\"headerlink\" title=\"golang struct注意事项：\"></a>golang struct注意事项：</h3><p>对于struct类型来说，字段的先后顺序是非常关键的。如果两个struct类型包含了完全相同的字段，但是排列顺序不同或者进行了部分合并，那么这两个struct就是不同的类型！</p>\n<p>如果struct字段是大写字母开头，那么该字段就是导出的（包外可见），这也符合Go语言的可见性规则。因此一个struct可以同时包含导出和未导出的变量。</p>\n","categories":["Go"],"tags":["Go,struct"]},{"title":"Go:关于Go语言:结构体(Struct)-方法(Method)-接收者(Receiver)类型的适用场景选择和命名约定(Go官方建议)","url":"https://wdft.com/2020/02/27/struct-method-receiver/","content":"<!-- toc -->\n\n<h1 id=\"关于Go语言-结构体-Struct-方法-Method-接收者-Receiver-类型的适用场景选择和命名约定-Go官方建议\"><a href=\"#关于Go语言-结构体-Struct-方法-Method-接收者-Receiver-类型的适用场景选择和命名约定-Go官方建议\" class=\"headerlink\" title=\"关于Go语言:结构体(Struct)-方法(Method)-接收者(Receiver)类型的适用场景选择和命名约定(Go官方建议)\"></a>关于Go语言:结构体(Struct)-方法(Method)-接收者(Receiver)类型的适用场景选择和命名约定(Go官方建议)</h1><h3 id=\"何时使用值类型场景\"><a href=\"#何时使用值类型场景\" class=\"headerlink\" title=\"何时使用值类型场景\"></a>何时使用值类型场景</h3><p>1.如果接受者是一个 map，func 或者 chan，使用值类型(因为它们本身就是引用类型)。<br>2.如果接受者是一个 slice，并且方法不执行 reslice 操作，也不重新分配内存给 slice，使用值类型。<br>3.如果接受者是一个小的数组或者原生的值类型结构体类型(比如 time.Time 类型)，而且没有可修改的字段和指针，又或者接受者是一个简单地基本类型像是 int 和 string，使用值类型就好了。<br>一个值类型的接受者可以减少一定数量的垃圾生成，如果一个值被传入一个值类型接受者的方法，一个栈上的拷贝会替代在堆上分配内存(但不是保证一定成功)，所以在没搞明白代码想干什么之前，别因为这个原因而选择值类型接受者。  </p>\n<h3 id=\"使用指针类型场景\"><a href=\"#使用指针类型场景\" class=\"headerlink\" title=\"使用指针类型场景\"></a>使用指针类型场景</h3><p>1.如果方法需要修改接受者，接受者必须是指针类型。<br>2.如果接受者是一个包含了 sync.Mutex 或者类似同步字段的结构体，接受者必须是指针，这样可以避免拷贝。<br>3.如果接受者是一个大的结构体或者数组，那么指针类型接受者更有效率。<br>4.从此方法中并发的调用函数和方法时，接受者可以被修改吗？一个值类型的接受者当方法调用时会创建一份拷贝，所以外部的修改不能作用到这个接受者上。如果修改必须被原始的接受者可见，那么接受者必须是指针类型。<br>5.如果接受者是一个结构体，数组或者 slice，它们中任意一个元素是指针类型而且可能被修改，建议使用指针类型接受者，这样会增加程序的可读性。  </p>\n<h3 id=\"Receiver接收者的命名\"><a href=\"#Receiver接收者的命名\" class=\"headerlink\" title=\"Receiver接收者的命名\"></a>Receiver接收者的命名</h3><p>1.社区约定的接受者命名是类型的一个或两个字母的缩写(像 c 或者 cl 对于 Client)。<br>2.避免使用泛指的名字像是 me，this 或者 self，也避免使用过度描述的名字；<br>3.如果你在一个地方使用了 c，那么就不要在别的地方使用 cl；  </p>\n<h3 id=\"自我总结\"><a href=\"#自我总结\" class=\"headerlink\" title=\"自我总结\"></a>自我总结</h3><p>一般使用场景下，决定是否使用指针，看数据单体(结构体、接口等等…)容量的大小(特别注意:注意切片slice、字典map、管道channel本身引用类型，底层本身是指针调用)，语言层面数据单体存储的形式是否本身就是指针类型，数据单体的作用范围和操作的范围，归根结底，还是要结合实际具体业务场景提前规划好数据结构,开发中多考虑数据单体的拷贝成本是否过高。<br>Go官方的使用建议，也是在Go内存分配和数据存储原理上的归纳总结。<br>Go语言虽然有指针但是没有包含指针计算，指针的操作也非常简单(这点考量特别地好,简单的结构可以让GC最低成本地监测内存运行状态,避免过多的指针关联,利于GC内存管理和回收)。  </p>\n","categories":["Go"],"tags":["Go,结构体(Struct)-方法(Method)-接收者(Receiver)类型"]},{"title":"Go:string","url":"https://wdft.com/2020/02/27/string/","content":"<!-- toc -->\n\n<h1 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h1><h3 id=\"常用拼接方法\"><a href=\"#常用拼接方法\" class=\"headerlink\" title=\"常用拼接方法\"></a>常用拼接方法</h3><ul>\n<li>+= 来拼接</li>\n<li>bytes.Buffer</li>\n<li>strings.Builder ( &gt;= go1.10 )</li>\n</ul>\n<h3 id=\"拼接方法性能对比\"><a href=\"#拼接方法性能对比\" class=\"headerlink\" title=\"拼接方法性能对比\"></a>拼接方法性能对比</h3><ul>\n<li>使用 += 的方法性能是最慢的，性能消耗相对最大;</li>\n<li>Buffer和Builder性能相差无几，Builder在内存的使用上要略优于Buffer;</li>\n<li>官方推荐strings.Builder，优点: 性能好，代码清晰;</li>\n</ul>\n","categories":["Go"],"tags":["Go,string"]},{"title":"Go:slice 切片本质","url":"https://wdft.com/2020/02/27/silce/","content":"<!-- toc -->\n\n<h1 id=\"go-切片：本质\"><a href=\"#go-切片：本质\" class=\"headerlink\" title=\"go 切片：本质\"></a>go 切片：本质</h1><h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>Go的切片是在数组之上的抽象数据类型，因此在了解切片之前必须要要理解数组。<br>数组类型由指定和长度和元素类型定义。<br>数组不需要显式的初始化；数组元素会自动初始化为零值：<br>Go的数组是值语义。一个数组变量表示整个数组，它不是指向第一个元素的指针（比如C语言的数组）。当一个数组变量被赋值或者被传递的时候，实际上会复制整个数组。（为了避免复制数组，你可以传递一个指向数组的指针，但是数组指针并不是数组。）可以将数组看作一个特殊的struct，结构的字段名对应数组的索引，同时成员的数目固定。</p>\n<h4 id=\"切片\"><a href=\"#切片\" class=\"headerlink\" title=\"切片\"></a>切片</h4><p>数组虽然有适用它们的地方，但是数组不够灵活，因此在Go代码中数组使用的并不多。但是，切片则使用得相当广泛。切片基于数组构建，但是提供更强的功能和便利。<br>切片的类型是 []T，T 是切片元素的类型。和数组不同的是，切片没有固定的长度。<br>切片的字面值和数组字面值很像，不过切片没有指定元素个数：<br>切片可以内置函数 make 创建，函数签名为：<br>func make([]T, len, cap) []T<br>T 代表被创建的切片元素的类型。函数 make 接受一个类型、一个长度和一个可选的容量参数。调用 make 时，内部会分配一个数组，然后返回数组对应的切片。<br>当容量参数被忽略时，它默认为指定的长度。下面是简洁的写法：<br>s := make([]byte, 5)<br>可以使用内置函数 len 和 cap 获取切片的长度和容量信息。<br>len(s) == 5<br>cap(s) == 5</p>\n<h3 id=\"长度和容量之间的关系。\"><a href=\"#长度和容量之间的关系。\" class=\"headerlink\" title=\"长度和容量之间的关系。\"></a>长度和容量之间的关系。</h3><p>零值的切片类型变量为 nil。对于零值切片变量，len 和 cap 都将返回 0。<br>切片也可以基于现有的切片或数组生成。切分的范围由两个由冒号分割的索引对应的半开区间指定。<br>切片的开始和结束的索引都是可选的；它们分别默认为零和数组的长度。</p>\n<h3 id=\"切片的本质\"><a href=\"#切片的本质\" class=\"headerlink\" title=\"切片的本质\"></a>切片的本质</h3><p>一个切片是一个数组切割区间的描述。它包含了指向数组的指针，切割区间的长度，和容量（切割区间的最大长度）。<br>切片并不复制整个切片元素。它创建一个新的切片执行同样的底层数组。这使得切片操作和数组索引一样高效。因此，通过一个新切片修改元素同样会影响到原始的切片。<br>切片增长不能超出其容量。增长超出切片容量将会导致运行时异常，就像切片或数组的索引超出范围引起异常一样。同样，不能使用小于零的索引去访问切片之前的元素。<br>切片生长（复制和追加）<br>要增加切片的容量必须创建一个新的、更大容量的切片，然后将原有切片的内容复制到新的切片。整个技术是一些支持动态数组语言的常见实现。<br>循环中复制的操作可以由 copy 内置函数替代。copy 函数将源切片的元素复制到目的切片。它返回复制元素的数目。<br>func copy(dst, src []T) int<br>copy 函数支持不同长度的切片之间的复制（它只复制最小切片长度的元素）。此外，copy 函数可以正确处理源和目的切片有重叠的情况。<br>但大多数程序不需要完全的控制，因此Go提供了一个内置函数 append，用于大多数场合；它的函数签名：<br>func append(s []T, x …T) []T<br>append函数将x追加到切片s的末尾，并且在必要的时候增加容量。<br>如果是要将一个切片追加到另一个切片尾部，需要使用…语法将第2个参数展开为参数列表。<br>可以声明一个零值切片（nil），然后在循环中向切片追加数据：</p>\n<p>可能的“陷阱”<br>切片操作并不会复制底层的数组。此层的数组将被保存在内存中，直到它不再被引用。有时候可能会因为一个小的内存引用导致保存所有的数据。</p>\n","categories":["Go"],"tags":["Go,slice切片本质"]},{"title":"Go:reflect 反射","url":"https://wdft.com/2020/02/27/reflect/","content":"<!-- toc -->\n\n<h1 id=\"reflect-反射\"><a href=\"#reflect-反射\" class=\"headerlink\" title=\"reflect 反射\"></a>reflect 反射</h1><h3 id=\"reflect-包类型定义\"><a href=\"#reflect-包类型定义\" class=\"headerlink\" title=\"reflect 包类型定义\"></a>reflect 包类型定义</h3><pre><code>//reflect 包类型定义\n\ntype Kind Sign\n\nconst (\n    Invalid Kind = iota  // 非法类型\n    Bool                 // 布尔型\n    Int                  // 有符号整型\n    Int8                 // 有符号8位整型\n    Int16                // 有符号16位整型\n    Int32                // 有符号32位整型\n    Int64                // 有符号64位整型\n    Uint                 // 无符号整型\n    Uint8                // 无符号8位整型\n    Uint16               // 无符号16位整型\n    Uint32               // 无符号32位整型\n    Uint64               // 无符号64位整型\n    Uintptr              // 指针\n    Float32              // 单精度浮点数\n    Float64              // 双精度浮点数\n    Complex64            // 64位复数类型\n    Complex128           // 128位复数类型\n    Array                // 数组\n    Chan                 // 通道\n    Func                 // 函数\n    Interface            // 接口\n    Map                  // 映射\n    Ptr                  // 指针\n    Slice                // 切片\n    String               // 字符串\n    Struct               // 结构体\n    UnsafePointer        // 底层指针\n)\n</code></pre><h3 id=\"反射性能的一般原则\"><a href=\"#反射性能的一般原则\" class=\"headerlink\" title=\"反射性能的一般原则\"></a>反射性能的一般原则</h3><p>基准测试结果的数值分析的一般原则建议：</p>\n<ul>\n<li>能使用原生代码时，尽量避免反射操作。</li>\n<li>提前缓冲反射值对象，对性能有很大的帮助。</li>\n<li>避免反射函数调用，实在需要调用时，先提前缓冲函数参数列表，并且尽量少地使用返回值。</li>\n</ul>\n","categories":["Go"],"tags":["Go,reflect 反射"]},{"title":"Go:polymorphism","url":"https://wdft.com/2020/02/27/polymorphism/","content":"<!-- toc -->\n\n<h1 id=\"polymorphism\"><a href=\"#polymorphism\" class=\"headerlink\" title=\"polymorphism\"></a>polymorphism</h1><h1 id=\"多态特性\"><a href=\"#多态特性\" class=\"headerlink\" title=\"多态特性\"></a>多态特性</h1><ul>\n<li>多态：同一件事情由于条件不同产生的结果不同；</li>\n<li>由于Go语言中结构体不能相互转换，所以没有结构体类型的多态，只有基于接口的多态。<br>这符合Go语言对面向对象的诠释； </li>\n</ul>\n<h1 id=\"多态和泛型的区别\"><a href=\"#多态和泛型的区别\" class=\"headerlink\" title=\"多态和泛型的区别\"></a>多态和泛型的区别</h1><ul>\n<li>泛型是当我们使用这个泛型类时候再去确定这个类里面的成员具体什么类型的，两者<em>本质</em>不是一个层次，多态不能实现泛型。</li>\n<li>多态是在继承层面上，即根据实际运行时候来确定具体的实现。</li>\n<li>泛型本质上并不是多态的一种特例，多态并不能实现泛型。</li>\n<li>引入泛型的本质是为了安全，把编译时能发现的错误不带到runtime运行时。</li>\n</ul>\n","categories":["Go"],"tags":["Go,Go-Polymorphism"]},{"title":"Go:fmt.Printf() 格式化占位符","url":"https://wdft.com/2020/02/27/printf/","content":"<!-- toc -->\n\n<h1 id=\"fmt-Printf-格式化占位符\"><a href=\"#fmt-Printf-格式化占位符\" class=\"headerlink\" title=\"fmt.Printf() 格式化占位符\"></a>fmt.Printf() 格式化占位符</h1><h3 id=\"格式符-fmt-Printf-quot-v-quot-variable\"><a href=\"#格式符-fmt-Printf-quot-v-quot-variable\" class=\"headerlink\" title=\"格式符 fmt.Printf(&quot;%v&quot;, variable)\"></a>格式符 <code>fmt.Printf(&quot;%v&quot;, variable)</code></h3><pre><code># 【通用占位符】\n    v 值的默认格式。\n    %+v 添加字段名(如结构体)\n    %#v　 相应值的Go语法表示\n    %T 相应值的类型的Go语法表示\n    %% 字面上的百分号，并非值的占位符　\n\n\n# 【布尔值】\n    %t true 或 false\n\n\n# 【整数值】\n    %b 二进制表示\n    %c 相应Unicode码点所表示的字符\n    %d 十进制表示\n    %o 八进制表示\n    %q 单引号围绕的字符字面值，由Go语法安全地转义\n    %x 十六进制表示，字母形式为小写 a-f\n    %X 十六进制表示，字母形式为大写 A-F\n    %U Unicode格式：U+1234，等同于 &quot;U+%04X&quot;\n\n\n# 【浮点数及复数】\n    %b 无小数部分的，指数为二的幂的科学计数法， \n       与 strconv.FormatFloat中的 &#39;b&#39; 转换格式一致。例如 -123456p-78\n    %e 科学计数法，例如 -1234.456e+78\n    %E 科学计数法，例如 -1234.456E+78\n    %f 有小数点而无指数，例如 123.456\n    %g 根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出\n    %G 根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出\n\n\n# 【字符串和bytes的slice表示】\n    %s 字符串或切片的无解译字节\n    %q 双引号围绕的字符串，由Go语法安全地转义\n    %x 十六进制，小写字母，每字节两个字符\n    %X 十六进制，大写字母，每字节两个字符\n\n\n# 【指针】\n    %p 十六进制表示，前缀 0x\n    这里没有 &#39;u&#39; 标记。若整数为无符号类型，他们就会被打印成无符号的。\n\n\n# 【精度和对齐方式】\n    〔输出最少宽度〕〔．精度〕〔长度〕类型\n    &quot;%-md&quot; ：左对齐，若m比实际少时，按实际输出。\n    &quot;%m.ns&quot;：输出m位，取字符串(左起)n位，左补空格，当n&gt;m or m省略时m=n\n    &quot;%m.nf&quot;：输出浮点数的输出宽度对齐，m为宽度，n为小数点右边数位\n\n\n# 【宽度和精度】\n    指示符(`f&#39;)为例：\n    %f:      默认宽度和精度 \n    %mf      宽度m, 默认精度 \n    %.nf     默认宽度, 精度n \n    %m.nf    宽度m, 精度n \n    %m.f     宽度m, 精度0\n    若遇到浮点数的指示符(`f&#39;)的话，它表示小数部分的位数。\n    若遇到浮点数的指示符(`e&#39;, `E&#39;, `g&#39;, `G&#39;)的话，它表示有效位数\n    若将精度设为`*&#39;的话，将从参数中提取精度的值\n    整数的指示符(`d&#39;, `i&#39;, `b&#39;, `o&#39;, `x&#39;, `X&#39;, `u&#39;)\n    其中对于字符串％s或者浮点类型％f,来说，精度可以截断数据的长度\n    &quot;%-md&quot; ：左对齐，若m比实际少时，按实际输出。\n    &quot;%m.ns&quot;：输出m位，取字符串(左起)n位，左补空格，当n&gt;m or m省略时m=n\n\n# 【显示参数占位符】\n    %[2]d, %[1]d     以%d为例：先输出第二个值，再输出第一个值.\n\n\n# 【特殊格式标识符】\n    +     总打印数值的正负号；对于%q（%+q）保证只输出ASCII编码的字符。 \n    -     左对齐 \n    #     备用格式：\n              为八进制添加前导 0（%#o），\n                  为十六进制添加前导 0x（%#x）或0X（%#X），为 %p（%#p）去掉前导 0x；\n              对于 %q，若 strconv.CanBackquote 返回 true，\n                  就会打印原始（即反引号围绕的）字符串；\n              如果是可打印字符，%U（%#U）会写出该字符的\n                  Unicode编码形式（如字符 x 会被打印成 U+0078 &#39;x&#39;）。 \n    &#39; &#39;  （空格）为数值中省略的正负号留出空白（% d）；\n          以十六进制（% x, % X）打印字符串或切片时，在字节之间用空格隔开 \n    0     填充前导的0而非空格；对于数字，这会将填充移到正负号之后\n</code></pre>","categories":["Go"],"tags":["Go,fmt.Printf() 格式化占位符"]},{"title":"Go:pointer","url":"https://wdft.com/2020/02/27/pointer/","content":"<!-- toc -->\n\n<h1 id=\"pointer-指针\"><a href=\"#pointer-指针\" class=\"headerlink\" title=\"pointer 指针\"></a>pointer 指针</h1><h3 id=\"基于指针对象的方法\"><a href=\"#基于指针对象的方法\" class=\"headerlink\" title=\"基于指针对象的方法\"></a>基于指针对象的方法</h3><p>当调用一个函数时，会对其每一个参数值进行拷贝，如果一个函数需要更新一个变量，或者函数的其中一个参数实在太大我们希望能够避免进行这种默认的拷贝，这种情况下我们就需要用到指针了。对应到我们这里用来更新接收器的对象的方法，当这个接受者变量本身比较大时，我们就可以用其指针而不是对象来声明方法，如下：</p>\n<p>func (p <em>Point) ScaleBy(factor float64) {<br>    p.X <em>= factor<br>    p.Y *= factor<br>}<br>这个方法的名字是(</em>Point).ScaleBy。这里的括号是必须的；没有括号的话这个表达式可能会被理解为</em>(Point.ScaleBy)。</p>\n<p>在现实的程序里，一般会约定如果Point这个类有一个指针作为接收器的方法，那么所有Point的方法都必须有一个指针接收器，即使是那些并不需要这个指针接收器的函数。我们在这里打破了这个约定只是为了展示一下两种方法的异同而已。</p>\n<p>只有类型(Point)和指向他们的指针(*Point)，才是可能会出现在接收器声明里的两种接收器。此外，为了避免歧义，在声明方法时，如果一个类型名本身是一个指针的话，是不允许其出现在接收器中的，比如下面这个例子：</p>\n<p>type P <em>int<br>func (P) f() { /</em> … <em>/ } // compile error: invalid receiver type<br>想要调用指针类型方法(</em>Point).ScaleBy，只要提供一个Point类型的指针即可，像下面这样。</p>\n<p>r := &amp;Point{1, 2}<br>r.ScaleBy(2)<br>fmt.Println(*r) // “{2, 4}”<br>或者这样：</p>\n<p>p := Point{1, 2}<br>pptr := &amp;p<br>pptr.ScaleBy(2)<br>fmt.Println(p) // “{2, 4}”<br>或者这样:</p>\n<p>p := Point{1, 2}<br>(&amp;p).ScaleBy(2)<br>fmt.Println(p) // “{2, 4}”<br>不过后面两种方法有些笨拙。幸运的是，go语言本身在这种地方会帮到我们。如果接收器p是一个Point类型的变量，并且其方法需要一个Point指针作为接收器，我们可以用下面这种简短的写法：</p>\n<p>p.ScaleBy(2)<br>编译器会隐式地帮我们用&amp;p去调用ScaleBy这个方法。这种简写方法只适用于“变量”，包括struct里的字段比如p.X，以及array和slice内的元素比如perim[0]。我们不能通过一个无法取到地址的接收器来调用指针方法，比如临时变量的内存地址就无法获取得到：</p>\n<p>Point{1, 2}.ScaleBy(2) // compile error: can’t take address of Point literal<br>但是我们可以用一个<em>Point这样的接收器来调用Point的方法，因为我们可以通过地址来找到这个变量，只要用解引用符号</em>来取到该变量即可。编译器在这里也会给我们隐式地插入*这个操作符，所以下面这两种写法等价的：</p>\n<p>pptr.Distance(q)<br>(*pptr).Distance(q)<br>这里的几个例子可能让你有些困惑，所以我们总结一下：在每一个合法的方法调用表达式中，也就是下面三种情况里的任意一种情况都是可以的：</p>\n<p>不论是接收器的实际参数和其接收器的形式参数相同，比如两者都是类型T或者都是类型*T：</p>\n<p>Point{1, 2}.Distance(q) //  Point<br>pptr.ScaleBy(2)         // <em>Point<br>或者接收器实参是类型T，但接收器形参是类型</em>T，这种情况下编译器会隐式地为我们取变量的地址：</p>\n<p>p.ScaleBy(2) // implicit (&amp;p)<br>或者接收器实参是类型*T，形参是类型T。编译器会隐式地为我们解引用，取到指针指向的实际变量：</p>\n<p>pptr.Distance(q) // implicit (<em>pptr)<br>如果命名类型T(译注：用type xxx定义的类型)的所有方法都是用T类型自己来做接收器(而不是</em>T)，那么拷贝这种类型的实例就是安全的；调用他的任何一个方法也就会产生一个值的拷贝。比如time.Duration的这个类型，在调用其方法时就会被全部拷贝一份，包括在作为参数传入函数的时候。但是如果一个方法使用指针作为接收器，你需要避免对其进行拷贝，因为这样可能会破坏掉该类型内部的不变性。比如你对bytes.Buffer对象进行了拷贝，那么可能会引起原始对象和拷贝对象只是别名而已，但实际上其指向的对象是一致的。紧接着对拷贝后的变量进行修改可能会有让你意外的结果。</p>\n<p>译注： 作者这里说的比较绕，其实有两点：</p>\n<p>不管你的method的receiver是指针类型还是非指针类型，都是可以通过指针/非指针类型进行调用的，编译器会帮你做类型转换。<br>在声明一个method的receiver该是指针还是非指针类型时，你需要考虑两方面的内部，第一方面是这个对象本身是不是特别大，如果声明为非指针变量时，调用会产生一次拷贝；第二方面是如果你用指针类型作为receiver，那么你一定要注意，这种指针类型指向的始终是一块内存地址，就算你对其进行了拷贝。熟悉C或者C艹的人这里应该很快能明白。</p>\n","categories":["Go"],"tags":["Go,pointer"]},{"title":"Go:null judge","url":"https://wdft.com/2020/02/27/null-judge/","content":"<!-- toc -->\n\n<h1 id=\"null-judge\"><a href=\"#null-judge\" class=\"headerlink\" title=\"null judge\"></a>null judge</h1><h3 id=\"int空值是0，\"><a href=\"#int空值是0，\" class=\"headerlink\" title=\"int空值是0，\"></a>int空值是0，</h3><h3 id=\"string空值是””而不是null或者nil（区别于其他语言），\"><a href=\"#string空值是””而不是null或者nil（区别于其他语言），\" class=\"headerlink\" title=\"string空值是””而不是null或者nil（区别于其他语言），\"></a>string空值是””而不是null或者nil（区别于其他语言），</h3><h3 id=\"Slice空值是长度为0的Slice而不是nil，\"><a href=\"#Slice空值是长度为0的Slice而不是nil，\" class=\"headerlink\" title=\"Slice空值是长度为0的Slice而不是nil，\"></a>Slice空值是长度为0的Slice而不是nil，</h3><h3 id=\"map空值是nil，\"><a href=\"#map空值是nil，\" class=\"headerlink\" title=\"map空值是nil，\"></a>map空值是nil，</h3><h3 id=\"error空值是nil，\"><a href=\"#error空值是nil，\" class=\"headerlink\" title=\"error空值是nil，\"></a>error空值是nil，</h3><h3 id=\"struct空值是一个“所有成员都是空值”的空Struct而不是nil，\"><a href=\"#struct空值是一个“所有成员都是空值”的空Struct而不是nil，\" class=\"headerlink\" title=\"struct空值是一个“所有成员都是空值”的空Struct而不是nil，\"></a>struct空值是一个“所有成员都是空值”的空Struct而不是nil，</h3><h3 id=\"不能单纯地判断一个struct是不是nil，因为它永远不可能是nil，可以通过返回一个error来判断是否为空，\"><a href=\"#不能单纯地判断一个struct是不是nil，因为它永远不可能是nil，可以通过返回一个error来判断是否为空，\" class=\"headerlink\" title=\"不能单纯地判断一个struct是不是nil，因为它永远不可能是nil，可以通过返回一个error来判断是否为空，\"></a>不能单纯地判断一个struct是不是nil，因为它永远不可能是nil，可以通过返回一个error来判断是否为空，</h3><h3 id=\"golang标准库里的常见做法：if-err-nil\"><a href=\"#golang标准库里的常见做法：if-err-nil\" class=\"headerlink\" title=\"golang标准库里的常见做法：if err != nil\"></a>golang标准库里的常见做法：if err != nil</h3>","categories":["Go"],"tags":["Go,Go null judge"]},{"title":"Go:Map","url":"https://wdft.com/2020/02/27/map/","content":"<!-- toc -->\n\n<h1 id=\"Map-要点\"><a href=\"#Map-要点\" class=\"headerlink\" title=\"Map 要点\"></a>Map 要点</h1><h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>map 是引用类型的： 内存用 make 方法来分配。</li>\n<li>new，永远用 make 来构造 map。new() 分配了一个引用对象，你会获得一个空引用的指针，相当于声明了一个未初始化的变量并且取了它的地址。</li>\n<li>当 map 增长到容量上限的时候，如果再增加新的 key-value 对，map 的大小会自动加 1。所以出于性能的考虑，对于大的 map 或者会快速扩张的 map，即使只是大概知道容量，也最好先标明。</li>\n</ul>\n<h3 id=\"特殊用法\"><a href=\"#特殊用法\" class=\"headerlink\" title=\"特殊用法\"></a>特殊用法</h3><p>用切片作为 map 的值</p>\n<pre><code>mp1 := make(map[int][]int)\nmp2 := make(map[int]*[]int)</code></pre><p>只遍历键KEY时，使用下面的形式,无须将值改为匿名变量形式，忽略值即可:  </p>\n<pre><code>for key := range mapData {\n    //Code ...\n}</code></pre><p>map清空：<br>无相关函数和方法。截至Go 1.12，清空唯一办法就是重新 make 一个新的 map。<br>但担心垃圾回收的效率，Go的GC的回收效率远高于一个清空函数。</p>\n<h3 id=\"map并发安全注意事项\"><a href=\"#map并发安全注意事项\" class=\"headerlink\" title=\"map并发安全注意事项\"></a>map并发安全注意事项</h3><h4 id=\"sync-Map有以下特性：\"><a href=\"#sync-Map有以下特性：\" class=\"headerlink\" title=\"sync.Map有以下特性：\"></a>sync.Map有以下特性：</h4><ul>\n<li>无须初始化，直接声明即可。</li>\n<li>sync.Map 不能使用 map 的方式进行取值和设置等操作，而是使用 sync.Map 的方法进行调用。<ul>\n<li>Store 表示存储，</li>\n<li>Load 表示获取，</li>\n<li>Delete 表示删除。</li>\n</ul>\n</li>\n<li>遍历操作 Range加回调函数，回调函数返回内部遍历出来的值。</li>\n<li>Range 参数中的回调函数的返回值功能是：<ul>\n<li>需要继续迭代遍历时，返回 true；</li>\n<li>终止迭代遍历时，返回false。</li>\n</ul>\n</li>\n</ul>\n<pre><code>#定义\nvar mapData sync.Map\n\n\n#遍历所有sync.Map中的键值对\nmapData.Range(func(k, v interface{}) bool {\n    fmt.Println(&quot;list-kv: %v , %v&quot;, k, v)\n    return true\n})\n</code></pre>","categories":["Go"],"tags":["Go,Map"]},{"title":"Go:new,make,struct{}","url":"https://wdft.com/2020/02/27/make-new/","content":"<!-- toc -->\n\n\n<h1 id=\"new-make-struct\"><a href=\"#new-make-struct\" class=\"headerlink\" title=\"new,make,struct{}\"></a>new,make,struct{}</h1><table>\n<thead>\n<tr>\n<th>函数</th>\n<th>适用范围</th>\n<th>返回值</th>\n<th align=\"right\">填充值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>make()</td>\n<td>仅限创建类型(slice map channel)</td>\n<td>引用，make返回复杂的结构为slice时:它是一个包含3个域的结构体：指向slice中第一个元素的指针，slice的长度，以及slice的容量。</td>\n<td align=\"right\">非零值，make(T, args)返回一个初始化的(而不是置零)，类型为T的值（而不是*T）。之所以有所不同，是因为这三个类型的背后引用了使用前必须初始化的数据结构</td>\n</tr>\n<tr>\n<td>new()</td>\n<td>所有类型</td>\n<td>指针，new返回一个指向已清零内存的指针，而make返回一个复杂的结构。</td>\n<td align=\"right\">零值，new(T)会为T类型的新项目，但new它并不初始化内存，只是将其置零</td>\n</tr>\n</tbody></table>\n<h4 id=\"备注：直接使用struct-来初始化strut时，返回的是一个struct类型的值，而不是指针。\"><a href=\"#备注：直接使用struct-来初始化strut时，返回的是一个struct类型的值，而不是指针。\" class=\"headerlink\" title=\"备注：直接使用struct{} 来初始化strut时，返回的是一个struct类型的值，而不是指针。\"></a>备注：直接使用struct{} 来初始化strut时，返回的是一个struct类型的值，而不是指针。</h4>","categories":["Go"],"tags":["Go,new,make,struct{}"]},{"title":"Go:JSON","url":"https://wdft.com/2020/02/27/json/","content":"<!-- toc -->\n\n\n<h1 id=\"JSON\"><a href=\"#JSON\" class=\"headerlink\" title=\"JSON\"></a>JSON</h1><h3 id=\"json-Marshal\"><a href=\"#json-Marshal\" class=\"headerlink\" title=\"json.Marshal()\"></a>json.Marshal()</h3><p>默认转换规则：<br>1.布尔型转换为 JSON 后仍是布尔型　， 如true -&gt; true<br>2.浮点型和整数型转换后为JSON里面的常规数字，如 1.23 -&gt; 1.23<br>3.字符串将以UTF-8编码转化输出为Unicode字符集的字符串，特殊字符比如&lt;将会被转义为\\u003c<br>4.数组和切片被转换为JSON 里面的数组，[]byte类会被转换为base64编码后的字符串，slice的零值被转换为null<br>5.结构体会转化为JSON对象，并且只有结构体里边以大写字母开头的可被导出的字段才会被转化输出，而这些可导出的字段会作为JSON对象的字符串索引<br>6.转化一个map 类型的数据结构时，该数据的类型必须是 map[string]T（T 可以是encoding/json 包支持的任意数据类型）  </p>\n<hr>\n<h3 id=\"json-Unmarshal\"><a href=\"#json-Unmarshal\" class=\"headerlink\" title=\"json.Unmarshal()\"></a>json.Unmarshal()</h3><p>注意：如果JSON中的字段在Go目标类型中不存在，json.Unmarshal() 函数在解码过程中会丢弃该字段。<br>未知类型,遵循规则：<br>1.JSON中的布尔值将会转换为Go中的bool类型<br>2.数值会被转换为Go中的float64类型<br>3.字符串转换后还是string类型<br>4.JSON数组会转换为[]interface{} 类型<br>5.JSON对象会转换为map[string]interface{}类型<br>6.null值会转换为nil   </p>\n","categories":["Go"],"tags":["Go,JSON"]},{"title":"Go:interface","url":"https://wdft.com/2020/02/27/interface/","content":"<!-- toc -->\n\n<h1 id=\"interface-接口\"><a href=\"#interface-接口\" class=\"headerlink\" title=\"interface 接口\"></a>interface 接口</h1><h3 id=\"go：interface-、断言与类型转换\"><a href=\"#go：interface-、断言与类型转换\" class=\"headerlink\" title=\"go：interface{}、断言与类型转换\"></a>go：interface{}、断言与类型转换</h3><ul>\n<li>Go的接口更大的作用是声明方法集合，而非类型约束。</li>\n<li>interface{}可用于向函数传递任意类型的变量，但对于函数内部，该变量仍然为interface{}类型（空接口类型），故必须进行类型断言确认类型后检查才能使用（不能直接隐式转换）。</li>\n<li>接口类型向普通类型的转换称为类型断言(运行期确定)。  </li>\n</ul>\n<h3 id=\"接口转换基本原则\"><a href=\"#接口转换基本原则\" class=\"headerlink\" title=\"接口转换基本原则\"></a>接口转换基本原则</h3><ul>\n<li>普通类型 =》 接口类型：编译器运行时隐式转换。</li>\n<li>接口类型 =》普通类型：必须显式类型断言。</li>\n<li>超集和子集转换关系：超转子可以，子转超不可以。</li>\n</ul>\n<h6 id=\"断言推荐方式：\"><a href=\"#断言推荐方式：\" class=\"headerlink\" title=\"断言推荐方式：\"></a>断言推荐方式：</h6><pre><code>\nb,ok:=a.([]int)\nif ok{\n    ...\n}\n\n//断言失败在编译阶段不会报错，故很可能出现断言失败导致运行错误。</code></pre><ul>\n<li>1.断言的作用：使用interface{}时，解决空接口类型向普通类型转换的类型转换问题；</li>\n<li>2.普通类型之间的转换，使用显式的类型转换，否则后果严重不可控。</li>\n</ul>\n<h3 id=\"interface值传递注意事项：\"><a href=\"#interface值传递注意事项：\" class=\"headerlink\" title=\"interface值传递注意事项：\"></a>interface值传递注意事项：</h3><ul>\n<li><p>如果接口实现方法，类型自己的实现使用的是值接收器，那么在传递值的时候无论使用指针还是值都可以。</p>\n</li>\n<li><p>如果接口实现方法，类型自己的实现使用的是指针接收器，那么在传递值的时候必须传递地址。</p>\n<pre><code>原因：编译器不能自动获得一个未声明地址。\n\n结构体类型定义的方法可以被该结构体的指针类型调用；而结构体类型调用该指针类型的方法时是被转换成指针，不是直接调用。\n接口实现方法时，用指针类型实现的接口函数只能算是指针类型实现的，用结构体类型实现的方法也作为是指针类型实现。\n</code></pre></li>\n</ul>\n<pre><code>\n### interface{} 与 []interface{}\n</code></pre><p>var dataSlice []int = foo()<br>var interfaceSlice []interface{} = dataSlice</p>\n<pre><code>**编译错误**  </code></pre><p>cannot use dataSlice (type []int) as type []interface { } in assignment  </p>\n<pre><code>任何类型赋值给interface{}，不能把任何类型的切片赋值到[]interface{}   \n **不能** 直接将某些[]MyType切片赋值给[]interface{}， 他们背后代表的数据意义不同。   \n</code></pre><p> //编译错误<br>//t := []int{1, 2, 3, 4} wrong<br>//var s []interface{} = t </p>\n<p>//正确<br>t := []int{1, 2, 3, 4} //right<br>s := make([]interface{}, len(t))<br>for i, v := range t {<br> s[i] = v<br>}</p>\n<pre><code>###### 接口转换\n* 利用类型推断，可判断接口对象是否某个具体的接口或类型。  \n* 还可用 switch 做批量类型判断，不支持 fallthrough。  \n* 超集接口对象可转换为子集接口，反之出错。  \n\n\n###### 原因：\n* []interface{}类型 **不是** interface{}类型， 它是一个切片，切片元素的类型恰好是interface{}。\n* []interface{}类型变量拥有特定的内存结构，这在编译时就已经决定。每个interface{}占两个字（word)，一个字用于存放interface存放的类型，另一个字用于存放实际数据或者是指向数据的指针。于是长度为N的[]interface{}类型切片背后是一个N*2字长的一块数据。   \n这与一般的[]MyType类型切片不同，相同长度的[]MyType切片背后的数据块大小为N*sizeof(MyType)字长。   \n\n###### 使用方式：\n如果想得到一个元素为任意类型的列表的容器，并且在索引其中元素之前会把它转换为原本的数据类型，可以直接使用interface{}即可。此种方式很通用（如果 **不是编译时类型安全** 的）也很快速。   \n\n\n### 接口类型内存布局(原理)\n\ninterface在内存上实际由两个成员组成\n* tab指向虚表(Virtual Table)\n* data则指向实际引用的数据。\n* 虚表描绘了实际的类型信息及该接口所需要的方法集。\n\n\n接口的底层结构\nruntime.h</code></pre><p>struct Iface<br>{<br>    Itab* tab;<br>    void* data;<br>};</p>\n<p>struct Itab<br>{<br>    InterfaceType* inter;<br>    Type* type;<br>    void (*fun[])(void);<br>};</p>\n<p>struct Itab<br>{<br>    InterfaceType* inter;<br>    Type* type;<br>    void (*fun[])(void);<br>};</p>\n<p>//只有 tab 和 data 都为 nil 时，接口才等于 nil。</p>\n<pre><code>\n接口Demo：</code></pre><p>package main</p>\n<p>import (<br>    “fmt”<br>)</p>\n<p>type People interface {<br>    Do()<br>}</p>\n<p>type Student struct {<br>    UserId   int<br>    UserName string<br>}</p>\n<p>func (s Student) Do() {<br>    s.UserName = “Jack Liu”<br>    return<br>}</p>\n<p>func main() {<br>    stu := Student{1, “Jack”}<br>    p := People(stu)//<br>    //a.Do()<br>    fmt.Printf(“%T %v”, p, p)<br>}</p>\n<pre><code>\nPeople接口本身，底层含有tab虚表和data实际存储的值两部分；    \n```p := People(Student{1, &quot;Jack&quot;})//此是合法的```，本质：    \n**通过接口进行函数调用** ，实际的操作其实就是```p.tab-&gt;fun[0](p.data)```;  \n\n###### 参考Go和C++的虚表的异同：\n* C++：\n    * c++ 的虚表是在编译时生成的，注意：表现出的多态是在runtime运行时决定;\n    * 每个class创建了一个方法集(虚表);\n    * 当子类重写父类的虚函数时，就将表中的相应函数指针改为子类自己实现的函数;\n    * 如果没有则指向父类的实现;\n    * 当面临多继承时，C++对象结构里就会存在多个虚表指针，每个虚表指针指向该方法集的不同部分。\n* Go:\n    * Go 接口的虚表是在runtime运行时生成；\n    * ``` p := People(Student{1, &quot;Jack&quot;})```生成People接口对应于Student类型的虚表，并将其缓存。\n###### 原因：\n* Go无继承关系，采用的是组合方式，所以不能进行虚表初始化(多少类型实现了某个接口，单个类型到底实现了多少接口这让编译器无从获知.\n* 选择在运行时生成虚表是自然的方案，放到runtime运行时，只要在需要接口的去分析一下类型是否实现了接口的所有方法即可，这样避免了去维护大量继承和绑定关系的心智负担，此并不会带来性能上的太大问题。\n* Go接口组合的方案和C++反其道而行之，本质上来说，各有优缺点。\n\n\n\n### 接口技巧\n让编译器检查，以确保某个类型实现接口。\n``` var _ fmt.Stringer = (*Data)(nil) ```\n\n某些时候，让函数直接 &quot;实现&quot; 接口能省不少事。</code></pre><p>type Tester interface {<br>    Do()<br>}</p>\n<p>type FuncDo func()<br>func (self FuncDo) Do() { self() }</p>\n<p>func main() {<br>    var t Tester = FuncDo(func() { println(“Hello, World!”) })<br>    t.Do()<br>}</p>\n<pre><code></code></pre>","categories":["Go"],"tags":["Go,interface"]},{"title":"Go:init()","url":"https://wdft.com/2020/02/27/init/","content":"<!-- toc -->\n\n<h1 id=\"init\"><a href=\"#init\" class=\"headerlink\" title=\"init()\"></a>init()</h1><h3 id=\"init-函数特性\"><a href=\"#init-函数特性\" class=\"headerlink\" title=\"init()函数特性\"></a>init()函数特性</h3><ul>\n<li>init()在main包执行之前</li>\n<li>init()自动执行,不能显示调用</li>\n<li>同一个Go文件中可定义多个init()函数，顺序执行</li>\n<li>同一个package中不同文件，将文件名按字符串进行字母和数字自然排序，之后顺序调用各文件中的init()</li>\n<li>import导入：<ul>\n<li>字符 <strong>_</strong> (下划线)操作，本质是引入package且不直接使用内部函数，仅仅调用init()初始化</li>\n<li>按照import导入顺序调用包中init()</li>\n<li>package的init()在被引用时自动被调用</li>\n<li>package存在依赖，调用顺序为最后被依赖的最先被执行初始化</li>\n<li>package被其他多个包import，只能被初始化一次</li>\n</ul>\n</li>\n</ul>\n","categories":["Go"],"tags":["Go,init()"]},{"title":"Go:chain operation","url":"https://wdft.com/2020/02/27/chain-operation/","content":"<!-- toc -->\n\n<h1 id=\"chain-operation\"><a href=\"#chain-operation\" class=\"headerlink\" title=\"chain operation\"></a>chain operation</h1><h3 id=\"链式调用注意事项\"><a href=\"#链式调用注意事项\" class=\"headerlink\" title=\"链式调用注意事项\"></a>链式调用注意事项</h3><ul>\n<li>本身为较宽泛的概念</li>\n<li>链式调用的场景：<ul>\n<li>返回值是一个函数或方法(很少有实际意义)；</li>\n<li>方法链（func chain或method chain）:返回值是一个对象时，可以直接调用对象绑定的方法；</li>\n</ul>\n</li>\n<li>链式调用方法链是包含关系，严格意义上说，链式调用​ <em>≠</em> 方法链；</li>\n</ul>\n<h3 id=\"链式调用的优点\"><a href=\"#链式调用的优点\" class=\"headerlink\" title=\"链式调用的优点\"></a>链式调用的优点</h3><ul>\n<li>调用过程更接近自然语言，链式呈现可读性好；</li>\n<li>参数列表复杂化的方法极大简化清晰；</li>\n<li>精简代码量，避免主操作对象反复的书写；</li>\n<li>优势:设计上，操作与数据分离、解耦;</li>\n</ul>\n<h3 id=\"链式调用的缺点\"><a href=\"#链式调用的缺点\" class=\"headerlink\" title=\"链式调用的缺点\"></a>链式调用的缺点</h3><ul>\n<li>开发者需要记住调用的层数，层数不能过多。</li>\n<li>每次调用都需要创建很深的调用堆栈，效率相对较低。</li>\n</ul>\n<h3 id=\"链式操作的实质\"><a href=\"#链式操作的实质\" class=\"headerlink\" title=\"链式操作的实质\"></a>链式操作的实质</h3><p>（函数OR方法）操作 =》 返回对象 =》继续操作返回对象所属函数OR方法</p>\n<pre><code>package main\n\nimport &quot;fmt&quot;\n\ntype A struct {\n    Aa string\n    Ab  int\n}\n\nfunc (p *A) SetAa(aa string) *A {\n    p.Aa = aa\n    return p //返回操作对象\n}\n\nfunc (p *A) SetAb(ab int) *A {\n    p.Ab = ab\n    return p //返回操作对象\n}\n\nfunc (p *A) Print()  {\n    fmt.Printf(&quot;Aa:%s || Ab:%d\\n&quot;, p.Aa, p.Ab)\n}\n\nfunc main() {\n    varA := &amp;A{}\n    varA.SetAa(&quot;Aa&quot;).SetAb(100).Print()\n}\n</code></pre>","categories":["Go"],"tags":["Go,Go-chain-operation"]},{"title":"Go:goroutine","url":"https://wdft.com/2020/02/27/goroutine/","content":"<!-- toc -->\n\n<h1 id=\"goroutine\"><a href=\"#goroutine\" class=\"headerlink\" title=\"goroutine\"></a>goroutine</h1><h3 id=\"Golang不使用OS层process而使用语言层面（Goroutine）处理-并发-amp-并行-Task任务方案-针对业务来说-的个人思考和实践思路随想-—Jack-Liu-秋\"><a href=\"#Golang不使用OS层process而使用语言层面（Goroutine）处理-并发-amp-并行-Task任务方案-针对业务来说-的个人思考和实践思路随想-—Jack-Liu-秋\" class=\"headerlink\" title=\"Golang不使用OS层process而使用语言层面（Goroutine）处理 并发 &amp; 并行 Task任务方案(针对业务来说)的个人思考和实践思路随想 —Jack Liu 秋\"></a>Golang不使用OS层process而使用语言层面（Goroutine）处理 并发 &amp; 并行 Task任务方案(针对业务来说)的个人思考和实践思路随想 —Jack Liu 秋</h3><p>1.使用OS层面进程管理，虽然成本低廉快捷，但对CPU的性能开销比较大，Golang通过Goroutine的引入，构建一种SandBox沙箱容器式的方案，可以将并发处理任务放在语言层面内部，“隔离“在系统层面之上，构建Goroutine池的同时，也能保证在性能可靠的前提下，安全性也增强。<br>目前大规模分布式系统的整体方向，大部分也都是建立在OS系统层之上(而非系统层面)以达到可控的标准控制，将OS系统级内核CPU的开销降到最低保证OS层流畅运行，这也让Linux为代表的服务器OS系统更“专注”做Base底层基础性的业务支撑。</p>\n<p>2.系统层面上，抛开编程语言层面不谈，服务端越来越趋于Service服务化和分布式、集群化，以此应对越来越复杂的业务。现有编程语言历史遗留和生态环境等因素处理的成本较高，针对多核CPU使用率也不高，性能问题凸显。<br>Golang在服务器端的优势在于，非常低成本将开发人员从以前的单进程类编程语言中解放，提供最低成本快速转变为并行编程的思维模式。<br>Goroutine并发执行的模式，不放在系统进程处理，好处：<br>（1）.安全隔离型设计，限制进程中Task Process处理的边界，在大规模集群服务器中使用相对统一的标准处理方式，最大限度规避OS层面的差异带来的问题；<br>（2）.降低OS进程的开销，不因golang的执行导致拖累系统CPU资源；<br>（3）.并发Task任务行为和状态可控，内存占用开销小，容量自由扩展；<br>（4）.轻量级在协程处理时可靠性高；<br>（5）.使用这种机制，可以较低成本构建大型和可伸缩计算和批处理Task任务的应用和程序，一开始Golang的定位就是系统级编程语言，所以二进制的运行性能不会差，现阶段的语言性能之争毫无意义。   </p>\n<p>目前业内针对业务处理的大型系统应用的常态应该至少包含两点：<br>1.支持最小成本组织大规模数据和计算处理；<br>2.Task任务的行为和状态能够可靠、低成本可控。  </p>\n<p>云计算追求对服务端在安全可控的前提下软硬件资源的最低成本配置和最佳的资源调度，做的所有分布式、自由伸缩、集群的重要原因也是源为此，Goroutines在这方面大有可为。  </p>\n<p>官方一句话说得比较直白和代表性：<br>Do not communicate by sharing memory; instead, share memory by communicating.<br>不要通过共享内存进行通信，而是通过通信共享内存。</p>\n<p>明确并发和并行的两个概念：<br>并发不是并行：并发是由切换时间来实现“同时”运行，并行是多核多线程<br>goroutine 通过通信来共享内存，而不是共享内存来通信。这样就可以较为充分利用多核CPU和内存资源的同时，又相对比较可靠，”协程”也是类似种”管道”的思维模式，在这里，通信显得比较重要，这些Golang已经做了底层化实现，对开发者来说比较简便一些，大部分精力放在管理好这些阀门出入口即可。<br>Linux的管道是非常优秀的设计。</p>\n<p>这个应该不是说以前的方案或其他语言处理思路是错误、不佳或有偏差的，历史上很多方案往往受制于硬件的运算性能综合因素考虑，是当时权衡下来的最好的方案，比如硬件成本太高等，现在随着软硬件的快速发展和成本低廉有这个条件来做这个事情了。终归是有当时基于现实情况的各种因素考量。<br>无论性能再怎么快，必须把可靠性放在重要位置，一个相对不可靠的方案，程序运行速度再快将毫无意义，我想这是Golang从软件工程化考虑的重要考量吧。  </p>\n<p>Golang设计哲学和Unix应该是一致的：大道至简，“简”是对大规模工程化系统开发中最好的思考范畴，虽万变仍不离其宗。 </p>\n<p>并发&amp;并行的编程理念对开发人员来说是未来编程思维的常态，事物发展的规律。  </p>\n<p>至少在公司产品和项目开发中，Golang至少是未来主力的语言，因为随着数据的不断增长，必须要一种从性能上，可靠性上和开发上相对最合适的技术选型，Golang是很符合这一点的，Golang不只是一个简单的编程语言这么简单。<br>C系的开发语言经久不衰很重要的原因就是追求用最简单的方式解决现实问题，Golang是未来考虑的主力开发语言。  </p>\n<h3 id=\"个人实践思路示意：\"><a href=\"#个人实践思路示意：\" class=\"headerlink\" title=\"个人实践思路示意：\"></a>个人实践思路示意：</h3><p> <img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==\" data-original=\"https://github.com/iotd/jackliu-golang-notes/blob/master/zh_CN/done-mode.jpg\" alt=\"image\"></p>\n<pre><code>                                                              --------- Jack Liu 秋    Date：2017-05-30</code></pre>","categories":["Go"],"tags":["Go,goroutine"]},{"title":"Go:func 函数","url":"https://wdft.com/2020/02/27/func/","content":"<!-- toc -->\n\n<h1 id=\"func-函数\"><a href=\"#func-函数\" class=\"headerlink\" title=\"func 函数\"></a>func 函数</h1><h3 id=\"func函数（适用于method）小结\"><a href=\"#func函数（适用于method）小结\" class=\"headerlink\" title=\"func函数（适用于method）小结\"></a>func函数（适用于method）小结</h3><h5 id=\"Go函数\"><a href=\"#Go函数\" class=\"headerlink\" title=\"Go函数\"></a>Go函数</h5><p>数也是一种类型，可以和其他类型一样被保存在变量中。和接口一样，接口也是一种类型。</p>\n<pre><code>package main\nimport (\n    &quot;fmt&quot;\n)\nfunc foo() {\n    fmt.Println(&quot;foo&quot;)\n}\nfunc main() {\n    var f func()\n    f = foo\n    f()\n}\n</code></pre><h5 id=\"Go函数类型实现接口——把函数作为接口来调用\"><a href=\"#Go函数类型实现接口——把函数作为接口来调用\" class=\"headerlink\" title=\"Go函数类型实现接口——把函数作为接口来调用\"></a>Go函数类型实现接口——把函数作为接口来调用</h5><p>函数体实现接口<br>函数的声明不能直接实现接口，需要将函数定义为类型后，使用类型实现结构体。当类型方法被调用时，还需要调用函数本体。</p>\n<pre><code>// 函数定义为类型\ntype FuncCaller func(interface{}) // func(interface{}) 定义为 FuncCaller 类型。\n// 实现Invoker的Call\nfunc (f FuncCaller) Call(p interface{}) {\n    // 调用f()函数本体\n    f(p) \n    //FuncCaller 的 Call() 方法将实现 Invoker 的 Call() 方法。\n    // FuncCaller 的 Call() 方法被调用与 func(interface{}) 无关，还需要手动调用函数本体。\n}\n\n//代码备注：\n//以上函数类型，需要函数本身进行逻辑处理。FuncCaller 无须被实例化，只需要将函数转\n//换为 FuncCaller 类型即可，函数来源可以是命名函数、匿名函数或闭包。\n</code></pre><h5 id=\"HTTP实现场景：\"><a href=\"#HTTP实现场景：\" class=\"headerlink\" title=\"HTTP实现场景：\"></a>HTTP实现场景：</h5><p>函数 handler() 转为 HandlerFunc 类型，HandlerFunc 类型实现了 Handler 的 ServeHTTP 方法，<br>底层可以同时使用各种类型来实现 Handler 接口进行处理。</p>\n<pre><code>HTTP 包中包含有 Handler 接口定义，代码如下：\ntype Handler interface {\n    ServeHTTP(ResponseWriter, *Request)\n}\nHandler 用于定义每个 HTTP 的请求和响应的处理过程。\n\n同时，也可以使用处理函数实现接口，定义如下：\ntype HandlerFunc func(ResponseWriter, *Request)\nfunc (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {\n    f(w, r)\n}\n要使用闭包实现默认的 HTTP 请求处理，可以使用 http.HandleFunc() 函数，函数定义如下：\nfunc HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {\n    DefaultServeMux.HandleFunc(pattern, handler)\n}\n而 DefaultServeMux 是 ServeMux 结构，拥有 HandleFunc() 方法，定义如下：\nfunc (mux *ServeMux) HandleFunc(pattern string, handler func\n(ResponseWriter, *Request)) {\n    mux.Handle(pattern, HandlerFunc(handler))\n}\n上面代码将外部传入的函数 handler() 转为 HandlerFunc 类型，HandlerFunc 类型实现了 Handler 的 ServeHTTP 方法，  \n底层可以同时使用各种类型来实现 Handler 接口进行处理。\n</code></pre><h5 id=\"Go可变参数函数调用注意事项（three-dots）\"><a href=\"#Go可变参数函数调用注意事项（three-dots）\" class=\"headerlink\" title=\"Go可变参数函数调用注意事项（three dots）\"></a>Go可变参数函数调用注意事项（three dots）</h5><ul>\n<li>若将 string 数组切片，每项独自传入函数，则会执行[]T{arg1,arg2}等类似操作，从新进行初始化；</li>\n<li>若将 interface{} 数组切片打散后直接传入函数，则不再进行对象的创建，直接试用该对象；</li>\n</ul>\n<h3 id=\"Go-…-three-dots-用法：\"><a href=\"#Go-…-three-dots-用法：\" class=\"headerlink\" title=\"Go … three dots 用法：\"></a>Go … three dots 用法：</h3><h5 id=\"变长的函数参数（逐一传参用法）\"><a href=\"#变长的函数参数（逐一传参用法）\" class=\"headerlink\" title=\"变长的函数参数（逐一传参用法）\"></a>变长的函数参数（逐一传参用法）</h5><p>调用参数最后一个…T，在参数列表的最后使用若干个类型为T的参数。<br>…T在函数内部的类型实际是[]T.</p>\n<h5 id=\"调用拥有变长参数列表的函数\"><a href=\"#调用拥有变长参数列表的函数\" class=\"headerlink\" title=\"调用拥有变长参数列表的函数\"></a>调用拥有变长参数列表的函数</h5><p>slice类型参数不必拆分调用，直接在slice后跟…</p>\n<h5 id=\"标识数组元素个数\"><a href=\"#标识数组元素个数\" class=\"headerlink\" title=\"标识数组元素个数\"></a>标识数组元素个数</h5><p>例如[…]int{1,2,3}</p>\n<h5 id=\"Go命令行中的通配符\"><a href=\"#Go命令行中的通配符\" class=\"headerlink\" title=\"Go命令行中的通配符\"></a>Go命令行中的通配符</h5><p>描述包文件的通配符。会执行当前目录和所有子目录的所有包：</p>\n<pre><code>\ngo test ./...\ngo run ./...\ngo build ./..\n</code></pre>","categories":["Go"],"tags":["Go,func"]},{"title":"Go:方法值(func value) 和 方法表达式(func expression)","url":"https://wdft.com/2020/02/27/func-value/","content":"<!-- toc -->\n\n<h1 id=\"方法值-func-value-amp-方法表达式-func-expression\"><a href=\"#方法值-func-value-amp-方法表达式-func-expression\" class=\"headerlink\" title=\"方法值(func value) &amp; 方法表达式(func expression)\"></a>方法值(func value) &amp; 方法表达式(func expression)</h1><h3 id=\"依据\"><a href=\"#依据\" class=\"headerlink\" title=\"依据\"></a>依据</h3><p>函数或方法具备两大特点：</p>\n<ul>\n<li>1.函数本身是一种类型T；</li>\n<li>2.函数变量：函数或方法本身储存在变量中；</li>\n</ul>\n<h3 id=\"方法值\"><a href=\"#方法值\" class=\"headerlink\" title=\"方法值\"></a>方法值</h3><p>方法值的本质是调用时隐藏了接收者，和传统调用是等价的；</p>\n<pre><code>package main\n\nimport &quot;fmt&quot;\n\ntype A struct {\n    name string\n}\n\nfunc (a *A) SetValue ()  {\n    fmt.Println(&quot;set&quot;)\n}\n\nfunc main() {\n    aa := A{&quot;jack&quot;}\n    //传统调用\n    aa.SetValue()\n\n    //方法值，调用时隐藏接收者\n    vFunc := aa.SetValue\n    vFunc()\n\n    //方法表达式，调用时隐藏接收者\n    aFunc := (*A).SetValue\n\n    //显式传递接收者,等价于aa.SetValue()\n    aFunc(&amp;aa)\n}\n</code></pre>","categories":["Go"],"tags":["Go,方法值(func value),方法表达式(func expression)"]},{"title":"Go tool pprof性能监控调试工具基本使用说明","url":"https://wdft.com/2020/02/27/Go-tool-pprof/","content":"<!-- toc -->\n\n<h4 id=\"Go-tool-pprof使用方式\"><a href=\"#Go-tool-pprof使用方式\" class=\"headerlink\" title=\"Go tool pprof使用方式\"></a>Go tool pprof使用方式</h4><p>go中有pprof包来做代码的性能监控主要涉及两个pkg：</p>\n<pre><code>#web服务器:\nimport (\n    &quot;net/http&quot;\n    _ &quot;net/http/pprof&quot;\n)\n\n#一般应用程序(实际应用无web交互)\nimport (\n    &quot;net/http&quot;\n    _ &quot;runtime/pprof&quot;\n)</code></pre><p>net/http/pprof中只是使用runtime/pprof包来进行封装了一下，并在http端口上暴露出来。</p>\n<h4 id=\"Go-tool-pprof辅助工具安装-图形工具graphviz为例\"><a href=\"#Go-tool-pprof辅助工具安装-图形工具graphviz为例\" class=\"headerlink\" title=\"Go tool pprof辅助工具安装(图形工具graphviz为例)\"></a>Go tool pprof辅助工具安装(图形工具graphviz为例)</h4><ul>\n<li><strong>Windows</strong>：  </li>\n</ul>\n<p>1.官方下载安装包: <a href=\"http://www.graphviz.org/download/\" target=\"_blank\" rel=\"noopener\">http://www.graphviz.org/download/</a><br>下载Stable稳定版本(.msi)<br>2.配置PATH系统环境变量：<br>C:\\Program Files (x86)\\Graphviz2.38\\bin  </p>\n<ul>\n<li><strong>Linux(例：Centos)</strong></li>\n</ul>\n<p>方式1).添加repo依赖<a href=\"http://204.178.9.49/graphviz-rhel.repo\" target=\"_blank\" rel=\"noopener\">http://204.178.9.49/graphviz-rhel.repo</a></p>\n<pre><code>yum list available &#39;graphviz*&#39;\nyum install &#39;graphviz*&#39;  --skip-broken\n#备注：--skip-broken可选：跳过错误依赖，不加这个参数会提示安装包依赖错误，因为这里并不需要其它的安装包，所以跳过即可。</code></pre><p>  –skip-broken可选：跳过错误依赖，不加这个参数会提示安装包依赖错误，因为这里并不需要其它的安装包，所以跳过即可。</p>\n<p>方式2).源码包编译安装<br>./configure<br>make<br>make install</p>\n<ul>\n<li><strong>MacOS</strong>:<br>brew install graphviz</li>\n</ul>\n<h4 id=\"Go-tool-pprof常用基本调试基本命令-默认30s采集时间，可通过–seconds\"><a href=\"#Go-tool-pprof常用基本调试基本命令-默认30s采集时间，可通过–seconds\" class=\"headerlink\" title=\"Go tool pprof常用基本调试基本命令(默认30s采集时间，可通过–seconds)\"></a>Go tool pprof常用基本调试基本命令(默认30s采集时间，可通过–seconds)</h4><h6 id=\"HTTP场景-参数可选-–text-：\"><a href=\"#HTTP场景-参数可选-–text-：\" class=\"headerlink\" title=\"HTTP场景(参数可选:–text)：\"></a>HTTP场景(参数可选:–text)：</h6><p>Heap profile:  </p>\n<pre><code>go tool pprof --text http://localhost:8080/debug/pprof/heap  </code></pre><p>CPU profile:  </p>\n<pre><code>go tool pprof --text http://localhost:8080/debug/pprof/profile  </code></pre><p>Goroutine blocking profile:  </p>\n<pre><code>go tool pprof --text http://localhost:8080/debug/pprof/block  </code></pre><p>1.实时通过地址查看浏览器: <a href=\"http://localhost:8080/debug/pprof/\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/debug/pprof/</a>;<br>2.通过生成的profile文件分析;<br>选择指定的profile压缩gz文件(.gz),使用go tool pprof进入</p>\n<pre><code>go tool pprof http://localhost:8080/debug/pprof/profile\n#结束后直接进入交互：\n(pprof)\n  web\n(pprof)</code></pre><p>如查看历史调试文件信息，通过指定的profile文件进入即可:<br>go tool pprof [*.gz]</p>\n<p>pprof交互基本命令：web 直接生成web浏览器可访问的svg图;<br>(其他命令自行摸索)<br>Windows下自动生成.svg文件且调用默认浏览器访问;<br>MacOS下自动生成.gz文件，系统限制可根据提示文件路径通过手动访问查看;  </p>\n<p>【注意事项】：<br>profile文件为空的问题, heap和block一般不受影响。<br>执行交互web命令会报:</p>\n<pre><code>(pprof) web\nprofile is empty\n(pprof) </code></pre><p>产生原因：<br>pprof内存分析器采取抽样的方式，它仅仅从一些内存分配的子集中收集信息。有可能对一个对象的采样与被采样对象的大小成比例。通过使用go test –memprofilerate标识，或者通过程序启动时 的运行配置中的MemProfileRate变量来改变调整这个采样的比例。如果比例为1，则会导致全部申请的信息都会被收集，但是这样的话将会使得执行变慢。默认的采样比例是每512KB的内存申请就采样一次。</p>\n<ul>\n<li>方法1).在进行调试时，指定运行参数，或运行代码中动态调整参数<pre><code>go tool pprof --text http://localhost:8080/debug/pprof/profile</code></pre>此命令将会打印耗费最多CPU时间的函数列表。<br>这里有几种可用的输出形式，最实用的有 –text, –web 和 –list。运行 “go tool pprof” 来得到完整的列表。 </li>\n</ul>\n<p>【备注】：<br>实际测试时，MacOS下基本是空的,需要指定参数。</p>\n<ul>\n<li><p>方法2).设置环境变量(<strong>此方法极不推荐!</strong>)设置Go环境变量 GODEBUG=”memprofilerate=1”.</p>\n</li>\n<li><p><strong>通过控制采样的比例和行为，可以达到性能调试粒度的控制！</strong></p>\n</li>\n</ul>\n","categories":["Go"],"tags":["Go,go-pprof"]},{"title":"Jack Liu's Golang personal summary combing notes","url":"https://wdft.com/2020/02/25/README/","content":"<!-- toc -->\n\n<h1 id=\"Jack-Liu’s-Golang-personal-summary-combing-notes\"><a href=\"#Jack-Liu’s-Golang-personal-summary-combing-notes\" class=\"headerlink\" title=\"Jack Liu’s Golang personal summary combing notes\"></a>Jack Liu’s Golang personal summary combing notes</h1><h4 id=\"Jack-Liu’s-Golang-personal-summary-notes-Go\"><a href=\"#Jack-Liu’s-Golang-personal-summary-notes-Go\" class=\"headerlink\" title=\"Jack Liu’s Golang personal summary notes Go\"></a>Jack Liu’s Golang personal summary notes Go</h4><h4 id=\"Jack-Liu’s-contact\"><a href=\"#Jack-Liu’s-contact\" class=\"headerlink\" title=\"Jack Liu’s contact\"></a>Jack Liu’s contact</h4><table>\n<thead>\n<tr>\n<th align=\"left\">Item</th>\n<th align=\"left\">Contact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Author</td>\n<td align=\"left\">Jack Liu</td>\n</tr>\n<tr>\n<td align=\"left\">Email</td>\n<td align=\"left\"><a href=\"mailto:stackgo@163.com\">stackgo@163.com</a></td>\n</tr>\n<tr>\n<td align=\"left\">WeChat</td>\n<td align=\"left\">laulinux</td>\n</tr>\n<tr>\n<td align=\"left\">QQ</td>\n<td align=\"left\">404691073</td>\n</tr>\n<tr>\n<td align=\"left\">Blog</td>\n<td align=\"left\"><a href=\"https://www.wdft.com\" target=\"_blank\" rel=\"noopener\">https://www.wdft.com</a></td>\n</tr>\n</tbody></table>\n<h6 id=\"I-love-Go，Simple-efficient-practical-engineered-…\"><a href=\"#I-love-Go，Simple-efficient-practical-engineered-…\" class=\"headerlink\" title=\"I love Go，Simple, efficient, practical, engineered …\"></a>I love Go，Simple, efficient, practical, engineered …</h6><h6 id=\"The-world-of-programming-should-be-pluralistic-free-from-any-one-mindset\"><a href=\"#The-world-of-programming-should-be-pluralistic-free-from-any-one-mindset\" class=\"headerlink\" title=\"The world of programming should be pluralistic, free from any one mindset.\"></a>The world of programming should be pluralistic, free from any one mindset.</h6><h4 id=\"EN-English-Documents\"><a href=\"#EN-English-Documents\" class=\"headerlink\" title=\"EN English Documents\"></a>EN English Documents</h4><p><a href=\"https://github.com/iotd/jackliu-golang-notes/tree/master/EN\" target=\"_blank\" rel=\"noopener\">English Documents</a></p>\n<h4 id=\"zh-CN-中文\"><a href=\"#zh-CN-中文\" class=\"headerlink\" title=\"zh_CN 中文\"></a>zh_CN 中文</h4><p><a href=\"https://github.com/iotd/jackliu-golang-notes/tree/master/zh_CN\" target=\"_blank\" rel=\"noopener\">README_CN</a></p>\n","categories":["Golang"],"tags":["Go"]},{"title":"about","url":"https://wdft.com/about/index.html","content":"","categories":[],"tags":[]},{"title":"CAT","url":"https://wdft.com/category/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"https://wdft.com/search/index.html","content":"","categories":[],"tags":[]},{"title":"link","url":"https://wdft.com/link/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"https://wdft.com/tag/index.html","content":"","categories":[],"tags":[]},{"title":"project","url":"https://wdft.com/project/index.html","content":"","categories":[],"tags":[]}]